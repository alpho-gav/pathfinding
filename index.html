<!DOCTYPE html>
<html>
<head>
    <title>Smooth Polygon Map with AI Pathfinding</title>
    <style>
        canvas {
            border: 1px solid black;
        }
        body {
            display: flex;
            flex-direction: column;
            align-items: center;
            margin: 20px;
        }
        button {
            margin: 10px;
            padding: 10px 20px;
            font-size: 16px;
        }
    </style>
</head>
<body>
    <button onclick="generateNewMap()">Generate New Map</button>
    <canvas id="gameCanvas" width="600" height="600"></canvas>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const width = canvas.width;
        const height = canvas.height;

        let obstacles = [];
        let player = { x: 50, y: 50 };
        let target = null;
        let path = [];

        generateNewMap();

        function generateNewMap() {
            obstacles = [];
            player = { x: 50, y: 50 };
            target = null;
            path = [];

            for (let i = 0; i < 8; i++) {
                const centerX = Math.random() * width;
                const centerY = Math.random() * height;
                const points = [];
                const numPoints = 5 + Math.floor(Math.random() * 4);
                const radius = 50 + Math.random() * 100;

                for (let j = 0; j < numPoints; j++) {
                    const angle = (j / numPoints) * Math.PI * 2;
                    const variation = (Math.random() - 0.5) * 30;
                    points.push({
                        x: centerX + Math.cos(angle) * (radius + variation),
                        y: centerY + Math.sin(angle) * (radius + variation)
                    });
                }
                obstacles.push(points);
            }
            // Ensure player start position is valid
            while (!isPointValid(player)) {
                player.x = Math.random() * width;
                player.y = Math.random() * height;
            }
            draw();
        }

        function draw() {
            ctx.clearRect(0, 0, width, height);

            ctx.fillStyle = '#666';
            obstacles.forEach(polygon => {
                ctx.beginPath();
                ctx.moveTo(polygon[0].x, polygon[0].y);
                for (let i = 1; i < polygon.length; i++) {
                    ctx.lineTo(polygon[i].x, polygon[i].y);
                }
                ctx.closePath();
                ctx.fill();
            });

            if (path.length > 0) {
                ctx.strokeStyle = 'rgba(0, 255, 0, 0.8)';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(path[0].x, path[0].y);
                for (let i = 1; i < path.length; i++) {
                    ctx.lineTo(path[i].x, path[i].y);
                }
                ctx.stroke();
            }

            ctx.fillStyle = 'blue';
            ctx.beginPath();
            ctx.arc(player.x, player.y, 10, 0, Math.PI * 2);
            ctx.fill();

            if (target) {
                ctx.fillStyle = 'red';
                ctx.beginPath();
                ctx.arc(target.x, target.y, 8, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        function isPointInPolygon(point, polygon) {
            let inside = false;
            for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
                const xi = polygon[i].x, yi = polygon[i].y;
                const xj = polygon[j].x, yj = polygon[j].y;
                
                const intersect = ((yi > point.y) !== (yj > point.y))
                    && (point.x < (xj - xi) * (point.y - yi) / (yj - yi) + xi);
                if (intersect) inside = !inside;
            }
            return inside;
        }

        function isPointValid(point) {
            return point.x >= 10 && point.x <= width - 10 && 
                   point.y >= 10 && point.y <= height - 10 &&
                   !obstacles.some(polygon => isPointInPolygon(point, polygon));
        }

        function findSmoothPath(start, end) {
            if (!isPointValid(end)) return [];

            let waypoints = [start];
            let current = { x: start.x, y: start.y };
            const maxSteps = 100;
            let step = 0;

            while (distance(current, end) > 15 && step < maxSteps) {
                step++;
                let directPathBlocked = false;
                let closestCollision = null;
                let minDist = Infinity;

                obstacles.forEach(polygon => {
                    for (let i = 0; i < polygon.length; i++) {
                        const p1 = polygon[i];
                        const p2 = polygon[(i + 1) % polygon.length];
                        const intersection = lineIntersection(current, end, p1, p2);
                        if (intersection) {
                            const d = distance(current, intersection);
                            if (d < minDist) {
                                minDist = d;
                                closestCollision = intersection;
                                directPathBlocked = true;
                            }
                        }
                    }
                });

                if (!directPathBlocked) {
                    waypoints.push(end);
                    break;
                } else {
                    const offset = 30; // Increased offset to avoid getting stuck
                    const direction = normalize({
                        x: end.x - current.x,
                        y: end.y - current.y
                    });
                    const perpendicular = { x: -direction.y, y: direction.x };
                    
                    // Try both directions to avoid getting stuck
                    let detour = {
                        x: closestCollision.x + perpendicular.x * offset,
                        y: closestCollision.y + perpendicular.y * offset
                    };
                    let detourValid = isPointValid(detour);
                    
                    if (!detourValid) {
                        detour = {
                            x: closestCollision.x - perpendicular.x * offset,
                            y: closestCollision.y - perpendicular.y * offset
                        };
                        detourValid = isPointValid(detour);
                    }

                    if (detourValid) {
                        waypoints.push(detour);
                        current = detour;
                    } else {
                        // Fallback: try smaller steps along the edge
                        const stepSize = 15;
                        const newPoint = {
                            x: current.x + direction.x * stepSize,
                            y: current.y + direction.y * stepSize
                        };
                        if (isPointValid(newPoint)) {
                            waypoints.push(newPoint);
                            current = newPoint;
                        } else {
                            break; // Give up if we can't find a valid path
                        }
                    }
                }
            }

            return smoothPath(waypoints);
        }

        function smoothPath(points) {
            if (points.length < 3) return points;
            
            const smoothed = [points[0]];
            for (let i = 1; i < points.length - 1; i++) {
                const prev = points[i - 1];
                const curr = points[i];
                const next = points[i + 1];
                
                const smoothedPoint = {
                    x: (prev.x + curr.x + next.x) / 3,
                    y: (prev.y + curr.y + next.y) / 3
                };
                if (isPointValid(smoothedPoint)) {
                    smoothed.push(smoothedPoint);
                } else {
                    smoothed.push(curr); // Keep original point if smoothing invalidates it
                }
            }
            smoothed.push(points[points.length - 1]);
            return smoothed;
        }

        function distance(p1, p2) {
            return Math.sqrt((p2.x - p1.x) ** 2 + (p2.y - p1.y) ** 2);
        }

        function normalize(vector) {
            const length = Math.sqrt(vector.x ** 2 + vector.y ** 2);
            return length > 0 ? { x: vector.x / length, y: vector.y / length } : vector;
        }

        function lineIntersection(p1, p2, p3, p4) {
            const denom = (p1.x - p2.x) * (p3.y - p4.y) - (p1.y - p2.y) * (p3.x - p4.x);
            if (denom === 0) return null;

            const t = ((p1.x - p3.x) * (p3.y - p4.y) - (p1.y - p3.y) * (p3.x - p4.x)) / denom;
            const u = -((p1.x - p2.x) * (p1.y - p3.y) - (p1.y - p2.y) * (p1.x - p3.x)) / denom;

            if (t > 0 && t < 1 && u > 0 && u < 1) {
                return {
                    x: p1.x + t * (p2.x - p1.x),
                    y: p1.y + t * (p2.y - p1.y)
                };
            }
            return null;
        }

        canvas.addEventListener('click', (e) => {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            target = { x, y };
            path = findSmoothPath(player, target);
            if (path.length > 0) {
                moveAlongPath();
            }
        });

        function moveAlongPath() {
            if (path.length > 0) {
                const next = path[0];
                const speed = 2; // Pixels per frame
                const dx = next.x - player.x;
                const dy = next.y - player.y;
                const dist = distance(player, next);

                if (dist <= speed) {
                    player = path.shift();
                } else {
                    const moveDist = normalize({ x: dx, y: dy });
                    player.x += moveDist.x * speed;
                    player.y += moveDist.y * speed;
                }

                draw();
                if (path.length > 0 || dist > speed) {
                    setTimeout(moveAlongPath, 50); // Slower update rate (20fps)
                }
            }
        }

        draw();
    </script>
</body>
</html>
