<!DOCTYPE html>
<html>
<head>
    <title>Random Map with AI Pathfinding</title>
    <style>
        canvas {
            border: 1px solid black;
        }
        body {
            display: flex;
            flex-direction: column;
            align-items: center;
            margin: 20px;
        }
        button {
            margin: 10px;
            padding: 10px 20px;
            font-size: 16px;
        }
    </style>
</head>
<body>
    <button onclick="generateNewMap()">Generate New Map</button>
    <canvas id="gameCanvas" width="600" height="600"></canvas>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const tileSize = 30;
        const gridWidth = canvas.width / tileSize;
        const gridHeight = canvas.height / tileSize;

        let map = [];
        let player = { x: 1, y: 1 };
        let target = null;
        let path = [];

        // Generate initial map
        generateNewMap();

        function generateNewMap() {
            // Reset variables
            map = [];
            player = { x: 1, y: 1 };
            target = null;
            path = [];

            // Generate random map (0 = walkable, 1 = wall)
            for (let y = 0; y < gridHeight; y++) {
                map[y] = [];
                for (let x = 0; x < gridWidth; x++) {
                    // 30% chance of wall, but keep edges clear for spawning
                    if (x === 0 || y === 0 || x === gridWidth - 1 || y === gridHeight - 1) {
                        map[y][x] = 0;
                    } else {
                        map[y][x] = Math.random() < 0.3 ? 1 : 0;
                    }
                }
            }
            draw();
        }

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Draw map
            for (let y = 0; y < gridHeight; y++) {
                for (let x = 0; x < gridWidth; x++) {
                    ctx.fillStyle = map[y][x] === 1 ? '#666' : '#fff';
                    ctx.fillRect(x * tileSize, y * tileSize, tileSize, tileSize);
                }
            }

            // Draw path
            if (path.length > 0) {
                ctx.fillStyle = 'rgba(0, 255, 0, 0.3)';
                path.forEach(node => {
                    ctx.fillRect(node.x * tileSize, node.y * tileSize, tileSize, tileSize);
                });
            }

            // Draw player
            ctx.fillStyle = 'blue';
            ctx.fillRect(player.x * tileSize, player.y * tileSize, tileSize, tileSize);

            // Draw target
            if (target) {
                ctx.fillStyle = 'red';
                ctx.fillRect(target.x * tileSize, target.y * tileSize, tileSize, tileSize);
            }
        }

        // A* Pathfinding
        function findPath(start, goal) {
            const openSet = [start];
            const closedSet = [];
            const cameFrom = new Map();
            const gScore = new Map();
            const fScore = new Map();

            gScore.set(`${start.x},${start.y}`, 0);
            fScore.set(`${start.x},${start.y}`, heuristic(start, goal));

            while (openSet.length > 0) {
                let current = openSet.reduce((a, b) => 
                    fScore.get(`${a.x},${a.y}`) < fScore.get(`${b.x},${b.y}`) ? a : b);

                if (current.x === goal.x && current.y === goal.y) {
                    return reconstructPath(cameFrom, current);
                }

                openSet.splice(openSet.indexOf(current), 1);
                closedSet.push(current);

                const neighbors = getNeighbors(current);
                for (let neighbor of neighbors) {
                    if (closedSet.some(node => node.x === neighbor.x && node.y === neighbor.y)) {
                        continue;
                    }

                    const tentativeGScore = gScore.get(`${current.x},${current.y}`) + 1;

                    if (!openSet.some(node => node.x === neighbor.x && node.y === neighbor.y)) {
                        openSet.push(neighbor);
                    } else if (tentativeGScore >= gScore.get(`${neighbor.x},${neighbor.y}`)) {
                        continue;
                    }

                    cameFrom.set(`${neighbor.x},${neighbor.y}`, current);
                    gScore.set(`${neighbor.x},${neighbor.y}`, tentativeGScore);
                    fScore.set(`${neighbor.x},${neighbor.y}`, tentativeGScore + heuristic(neighbor, goal));
                }
            }
            return []; // No path found
        }

        function heuristic(a, b) {
            return Math.abs(a.x - b.x) + Math.abs(a.y - b.y); // Manhattan distance
        }

        function getNeighbors(node) {
            const neighbors = [];
            const directions = [[0, 1], [1, 0], [0, -1], [-1, 0]];
            for (let [dx, dy] of directions) {
                const newX = node.x + dx;
                const newY = node.y + dy;
                if (newX >= 0 && newX < gridWidth && newY >= 0 && newY < gridHeight && map[newY][newX] === 0) {
                    neighbors.push({ x: newX, y: newY });
                }
            }
            return neighbors;
        }

        function reconstructPath(cameFrom, current) {
            const path = [current];
            while (cameFrom.has(`${current.x},${current.y}`)) {
                current = cameFrom.get(`${current.x},${current.y}`);
                path.unshift(current);
            }
            return path;
        }

        // Handle click/tap
        canvas.addEventListener('click', (e) => {
            const rect = canvas.getBoundingClientRect();
            const x = Math.floor((e.clientX - rect.left) / tileSize);
            const y = Math.floor((e.clientY - rect.top) / tileSize);

            if (map[y][x] === 0) { // Only move to walkable tiles
                target = { x, y };
                path = findPath(player, target);
                if (path.length > 0) {
                    moveAlongPath();
                }
            }
        });

        function moveAlongPath() {
            if (path.length > 0) {
                player = path.shift();
                draw();
                setTimeout(moveAlongPath, 100); // Move every 100ms
            }
        }

        draw();
    </script>
</body>
</html>
